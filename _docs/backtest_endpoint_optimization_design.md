# æ—©æœŸãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¼ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆå°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ - å®Œå…¨è¨­è¨ˆæ›¸

## ğŸ¯ å®Œæˆå½¢ã®ç†æƒ³çš„ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼

### ğŸ”„ æœ€é©åŒ–å¾Œã®7æ®µéšå‡¦ç†

```mermaid
graph TD
    A[1. ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼] --> B[2. æ”¯æŒç·šãƒ»æŠµæŠ—ç·šæ¤œå‡º]
    B --> C[3. å¸‚å ´ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†æ]
    C --> D[4. MLäºˆæ¸¬ãƒ»å¼·åŒ–]
    D --> E[5. ãƒ¬ãƒãƒ¬ãƒƒã‚¸æœ€é©åŒ–]
    E --> F[6. æ©Ÿä¼šæ¤œè¨¼ãƒ«ãƒ¼ãƒ—<br/>9æ®µéšãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°]
    F --> G[7. çµæœé›†è¨ˆãƒ»ä¿å­˜]
```

### ğŸ“‹ 6æ®µéšç›®ï¼šæ©Ÿä¼šæ¤œè¨¼ãƒ«ãƒ¼ãƒ—ã®è©³ç´°è¨­è¨ˆ

#### ğŸ” 9æ®µéšæ—©æœŸãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 

| ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ | é‡é‡ | å®Ÿè¡Œæ™‚é–“ | é™¤å¤–å¯¾è±¡ | é™¤å¤–ç‡ç›®å®‰ |
|------------|------|----------|----------|------------|
| **Filter 1: ãƒ‡ãƒ¼ã‚¿å“è³ª** | è»½é‡ | ~1ç§’ | ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ç•°å¸¸ã€ãƒ‡ãƒ¼ã‚¿æ¬ æ | 1-2% |
| **Filter 2: åŸºæœ¬å¸‚å ´æ¡ä»¶** | è»½é‡ | ~3ç§’ | ä½å–å¼•é‡ã€åºƒã„ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ | 25-30% |
| **Filter 3: æ”¯æŒç·šãƒ»æŠµæŠ—ç·šå­˜åœ¨** | è»½é‡ | ~8ç§’ | æœ‰åŠ¹ãªãƒ¬ãƒ™ãƒ«ãªã— | 20-25% |
| **Filter 4: è·é›¢ãƒ»å¼·åº¦æ¡ä»¶** | ä¸­é‡é‡ | ~15ç§’ | è·é›¢ä¸é©åˆ‡ã€å¼·åº¦ä¸è¶³ | 15-20% |
| **Filter 5: MLä¿¡é ¼åº¦æ¡ä»¶** | ä¸­é‡é‡ | ~20ç§’ | ä½MLä¿¡é ¼åº¦ | 20-25% |
| **Filter 6: ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£æ¡ä»¶** | ä¸­é‡é‡ | ~25ç§’ | éåº¦ãªãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ | 5-10% |
| **Filter 7: ãƒ¬ãƒãƒ¬ãƒƒã‚¸å¦¥å½“æ€§** | é‡é‡ | ~35ç§’ | ãƒ¬ãƒãƒ¬ãƒƒã‚¸è¨ˆç®—ä¸å¯ | 3-5% |
| **Filter 8: ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”** | é‡é‡ | ~40ç§’ | ä¸åˆ©ãªRRæ¯” | 2-3% |
| **Filter 9: æˆ¦ç•¥å›ºæœ‰æ¡ä»¶** | é‡é‡ | ~45ç§’ | æˆ¦ç•¥ç‰¹æœ‰ã®é™¤å¤–æ¡ä»¶ | 1-2% |

#### ğŸ“Š ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°åŠ¹æœäºˆæ¸¬

```
è©•ä¾¡æ™‚ç‚¹: 5000å€‹
â”œâ”€ Filter 1 (ãƒ‡ãƒ¼ã‚¿å“è³ª) â†’ 4950å€‹ (50å€‹é™¤å¤–, 1%)
â”œâ”€ Filter 2 (å¸‚å ´æ¡ä»¶) â†’ 3465å€‹ (1485å€‹é™¤å¤–, 30%)
â”œâ”€ Filter 3 (æ”¯æŒç·šãƒ»æŠµæŠ—ç·š) â†’ 2772å€‹ (693å€‹é™¤å¤–, 20%)
â”œâ”€ Filter 4 (è·é›¢ãƒ»å¼·åº¦) â†’ 2217å€‹ (555å€‹é™¤å¤–, 20%)
â”œâ”€ Filter 5 (MLä¿¡é ¼åº¦) â†’ 1662å€‹ (555å€‹é™¤å¤–, 25%)
â”œâ”€ Filter 6 (ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£) â†’ 1496å€‹ (166å€‹é™¤å¤–, 10%)
â”œâ”€ Filter 7 (ãƒ¬ãƒãƒ¬ãƒƒã‚¸) â†’ 1421å€‹ (75å€‹é™¤å¤–, 5%)
â”œâ”€ Filter 8 (ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰) â†’ 1378å€‹ (43å€‹é™¤å¤–, 3%)
â””â”€ Filter 9 (æˆ¦ç•¥å›ºæœ‰) â†’ 1364å€‹ (14å€‹é™¤å¤–, 1%)

æœ€çµ‚å®Ÿè¡Œ: 1364å€‹ (ç´„27%ãŒæœ‰åŠ¹æ©Ÿä¼šã¨ã—ã¦ç‰¹å®š)
å‡¦ç†æ™‚é–“å‰Šæ¸›: 73%çŸ­ç¸® (5000â†’1364å€‹ã®ã¿é‡ã„å‡¦ç†å®Ÿè¡Œ)
```

## ğŸ› ï¸ å®Ÿè£…ä½œæ¥­ã®æ®µéšçš„æ‰‹é †

### Phase 1: åŸºç›¤æ•´å‚™ (å·¥æ•°: 3-4æ—¥)

#### ğŸ“ ä½œæ¥­é …ç›®

**1. æ–°ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ§‹ç¯‰**
```python
# engines/filtering_framework.py (æ–°è¦ä½œæˆ, 150è¡Œ)
class FilteringFramework:
    def __init__(self, strategy, prepared_data):
        self.strategy = strategy
        self.prepared_data = prepared_data
        self.filter_chain = self._build_filter_chain()
        self.stats = {f"filter_{i}": 0 for i in range(1, 10)}
    
    def _build_filter_chain(self):
        """æˆ¦ç•¥ã«å¿œã˜ãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒã‚§ãƒ¼ãƒ³ã‚’æ§‹ç¯‰"""
        return [
            DataQualityFilter(),           # Filter 1
            MarketConditionFilter(),       # Filter 2
            SupportResistanceFilter(),     # Filter 3
            DistanceAnalysisFilter(),      # Filter 4
            MLConfidenceFilter(),          # Filter 5
            VolatilityFilter(),            # Filter 6
            LeverageFilter(),              # Filter 7
            RiskRewardFilter(),            # Filter 8
            StrategySpecificFilter(self.strategy)  # Filter 9
        ]
    
    def execute_filtering(self, evaluation_times):
        """9æ®µéšãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å®Ÿè¡Œ"""
        valid_trades = []
        
        for idx, evaluation_time in enumerate(evaluation_times):
            if self._execute_filter_chain(evaluation_time):
                trade = self._execute_trade_simulation(evaluation_time)
                valid_trades.append(trade)
            
            # é€²æ—æ›´æ–°
            if idx % 100 == 0:
                self._update_progress(idx, len(evaluation_times), len(valid_trades))
        
        self._log_filtering_statistics(len(evaluation_times), len(valid_trades))
        return valid_trades
    
    def _execute_filter_chain(self, evaluation_time):
        """å„ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’é †æ¬¡å®Ÿè¡Œã€ã„ãšã‚Œã‹ã§é™¤å¤–ã•ã‚Œã‚Œã°å³åº§ã«åœæ­¢"""
        for i, filter in enumerate(self.filter_chain, 1):
            try:
                result = filter.apply(evaluation_time, self.prepared_data, self.strategy)
                if not result.passed:
                    self.stats[f"filter_{i}"] += 1
                    logger.debug(f"F{i}é™¤å¤–: {evaluation_time} - {result.reason}")
                    return False
            except Exception as e:
                logger.error(f"Filter {i} error: {e}")
                self.stats[f"filter_{i}"] += 1
                return False
        
        return True  # å…¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é€šé
```

**2. å„ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¯ãƒ©ã‚¹ã®åŸºåº•å®Ÿè£…**
```python
# engines/filters/base_filter.py (æ–°è¦ä½œæˆ, 80è¡Œ)
class BaseFilter:
    def __init__(self, name, weight, timeout_seconds):
        self.name = name
        self.weight = weight  # è»½é‡(1), ä¸­é‡é‡(2), é‡é‡(3)
        self.timeout_seconds = timeout_seconds
    
    def apply(self, evaluation_time, prepared_data, strategy) -> FilterResult:
        """ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ï¼ˆå„ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…ï¼‰"""
        raise NotImplementedError
    
    def get_execution_time_estimate(self) -> float:
        """æ¨å®šå®Ÿè¡Œæ™‚é–“ã‚’è¿”ã™"""
        return self.timeout_seconds
    
    def validate_input(self, evaluation_time, prepared_data, strategy):
        """å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯"""
        if not prepared_data:
            raise ValueError("prepared_data is required")
        if not strategy:
            raise ValueError("strategy is required")

class FilterResult:
    def __init__(self, passed: bool, reason: str = "", metrics: dict = None):
        self.passed = passed
        self.reason = reason
        self.metrics = metrics or {}
        self.timestamp = datetime.now()
```

**3. auto_symbol_training.py ã®æ”¹ä¿®**
```python
# auto_symbol_training.py ã¸ã®è¿½åŠ  (50è¡Œ)
async def _execute_opportunity_validation(self, symbol, strategies, current_execution_id):
    """æ©Ÿä¼šæ¤œè¨¼ãƒ•ã‚§ãƒ¼ã‚ºã®å®Ÿè£…"""
    
    # æº–å‚™ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
    prepared_data = self._get_prepared_analysis_data(current_execution_id)
    
    all_results = {}
    total_strategies = len(strategies)
    
    for strategy_idx, strategy in enumerate(strategies, 1):
        logger.info(f"ğŸ” {strategy} æ©Ÿä¼šæ¤œè¨¼é–‹å§‹ ({strategy_idx}/{total_strategies})")
        
        # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯åˆæœŸåŒ–
        filtering_framework = FilteringFramework(strategy, prepared_data)
        
        # è©•ä¾¡æ™‚ç‚¹ã®ç”Ÿæˆ
        evaluation_times = self._generate_evaluation_times(strategy)
        logger.info(f"ğŸ“Š è©•ä¾¡æ™‚ç‚¹æ•°: {len(evaluation_times)}å€‹")
        
        # æ©Ÿä¼šæ¤œè¨¼å®Ÿè¡Œ
        start_time = time.time()
        valid_trades = filtering_framework.execute_filtering(evaluation_times)
        execution_time = time.time() - start_time
        
        # çµæœè¨˜éŒ²
        filtering_efficiency = len(valid_trades) / len(evaluation_times) * 100
        all_results[strategy] = {
            'trades': valid_trades,
            'total_evaluations': len(evaluation_times),
            'valid_opportunities': len(valid_trades),
            'filtering_efficiency': filtering_efficiency,
            'execution_time': execution_time,
            'filter_statistics': filtering_framework.stats
        }
        
        logger.info(f"âœ… {strategy} å®Œäº†: {len(valid_trades)}/{len(evaluation_times)} æ©Ÿä¼š ({filtering_efficiency:.1f}%)")
        logger.info(f"â±ï¸ å®Ÿè¡Œæ™‚é–“: {execution_time:.1f}ç§’")
    
    return all_results
```

#### ğŸ”§ å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«
- `engines/filtering_framework.py` (æ–°è¦, 150è¡Œ)
- `engines/filters/base_filter.py` (æ–°è¦, 80è¡Œ)
- `engines/filters/` ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª (æ–°è¦)
- `auto_symbol_training.py` (50è¡Œè¿½åŠ )

### Phase 2: ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ­ã‚¸ãƒƒã‚¯å®Ÿè£… (å·¥æ•°: 5-6æ—¥)

#### ğŸ“ è»½é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å®Ÿè£…ï¼ˆFilter 1-3ï¼‰

```python
# engines/filters/lightweight_filters.py (æ–°è¦ä½œæˆ, 120è¡Œ)
class DataQualityFilter(BaseFilter):
    def __init__(self):
        super().__init__("data_quality", weight=1, timeout_seconds=1)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # ä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        current_price = prepared_data.get_price_at(evaluation_time)
        if current_price <= 0:
            return FilterResult(False, "Invalid price data: price <= 0")
        
        # ç•°å¸¸ãªä¾¡æ ¼å¤‰å‹•ãƒã‚§ãƒƒã‚¯
        if prepared_data.has_price_anomaly_at(evaluation_time):
            return FilterResult(False, "Price anomaly detected")
        
        # ãƒ‡ãƒ¼ã‚¿æ¬ æãƒã‚§ãƒƒã‚¯
        if prepared_data.has_missing_data_around(evaluation_time):
            return FilterResult(False, "Missing OHLCV data around timepoint")
        
        return FilterResult(True, "Data quality validation passed", 
                          {"current_price": current_price})

class MarketConditionFilter(BaseFilter):
    def __init__(self):
        super().__init__("market_condition", weight=1, timeout_seconds=3)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # å–å¼•é‡ãƒã‚§ãƒƒã‚¯
        volume = prepared_data.get_volume_at(evaluation_time)
        if volume < strategy.min_volume_threshold:
            return FilterResult(False, f"Low volume: {volume} < {strategy.min_volume_threshold}")
        
        # ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ãƒã‚§ãƒƒã‚¯
        spread = prepared_data.get_spread_at(evaluation_time)
        if spread > strategy.max_spread_threshold:
            return FilterResult(False, f"Wide spread: {spread} > {strategy.max_spread_threshold}")
        
        # åŸºæœ¬çš„ãªæµå‹•æ€§ãƒã‚§ãƒƒã‚¯
        liquidity_score = prepared_data.get_liquidity_score_at(evaluation_time)
        if liquidity_score < strategy.min_liquidity_score:
            return FilterResult(False, f"Low liquidity: {liquidity_score}")
        
        return FilterResult(True, "Market conditions acceptable", 
                          {"volume": volume, "spread": spread, "liquidity_score": liquidity_score})

class SupportResistanceFilter(BaseFilter):
    def __init__(self):
        super().__init__("support_resistance", weight=1, timeout_seconds=8)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # äº‹å‰è¨ˆç®—ã•ã‚ŒãŸæ”¯æŒç·šãƒ»æŠµæŠ—ç·šã‹ã‚‰è©²å½“æ™‚ç‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        sr_data = prepared_data.get_support_resistance_at(evaluation_time)
        
        if not sr_data.support_levels and not sr_data.resistance_levels:
            return FilterResult(False, "No support/resistance levels found")
        
        # æœ€ä½é™ã®å¼·åº¦ãƒã‚§ãƒƒã‚¯
        max_support_strength = max([s.strength for s in sr_data.support_levels] or [0])
        max_resistance_strength = max([r.strength for r in sr_data.resistance_levels] or [0])
        
        if max_support_strength < strategy.min_support_strength:
            return FilterResult(False, f"Weak support strength: {max_support_strength:.2f}")
        
        if max_resistance_strength < strategy.min_resistance_strength:
            return FilterResult(False, f"Weak resistance strength: {max_resistance_strength:.2f}")
        
        return FilterResult(True, 
                          f"Found {len(sr_data.support_levels)} supports, {len(sr_data.resistance_levels)} resistances",
                          {
                              "support_count": len(sr_data.support_levels),
                              "resistance_count": len(sr_data.resistance_levels),
                              "max_support_strength": max_support_strength,
                              "max_resistance_strength": max_resistance_strength
                          })
```

#### ğŸ“ ä¸­é‡é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å®Ÿè£…ï¼ˆFilter 4-6ï¼‰

```python
# engines/filters/medium_filters.py (æ–°è¦ä½œæˆ, 100è¡Œ)
class DistanceAnalysisFilter(BaseFilter):
    def __init__(self):
        super().__init__("distance_analysis", weight=2, timeout_seconds=15)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        sr_data = prepared_data.get_support_resistance_at(evaluation_time)
        current_price = prepared_data.get_price_at(evaluation_time)
        
        # æ”¯æŒç·šã¾ã§ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        nearest_support = sr_data.get_nearest_support(current_price)
        if nearest_support:
            support_distance_pct = (current_price - nearest_support.price) / current_price * 100
            if support_distance_pct < strategy.min_support_distance_pct:
                return FilterResult(False, f"Too close to support: {support_distance_pct:.1f}%")
            if support_distance_pct > strategy.max_support_distance_pct:
                return FilterResult(False, f"Too far from support: {support_distance_pct:.1f}%")
        
        # æŠµæŠ—ç·šã¾ã§ã®è·é›¢ãƒã‚§ãƒƒã‚¯
        nearest_resistance = sr_data.get_nearest_resistance(current_price)
        if nearest_resistance:
            resistance_distance_pct = (nearest_resistance.price - current_price) / current_price * 100
            if resistance_distance_pct < strategy.min_resistance_distance_pct:
                return FilterResult(False, f"Too close to resistance: {resistance_distance_pct:.1f}%")
            if resistance_distance_pct > strategy.max_resistance_distance_pct:
                return FilterResult(False, f"Too far from resistance: {resistance_distance_pct:.1f}%")
        
        return FilterResult(True, "Distance analysis passed",
                          {
                              "support_distance_pct": support_distance_pct if nearest_support else None,
                              "resistance_distance_pct": resistance_distance_pct if nearest_resistance else None
                          })

class MLConfidenceFilter(BaseFilter):
    def __init__(self):
        super().__init__("ml_confidence", weight=2, timeout_seconds=20)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # äº‹å‰è¨“ç·´ã•ã‚ŒãŸMLãƒ¢ãƒ‡ãƒ«ã§äºˆæ¸¬
        ml_model = prepared_data.get_ml_model()
        features = prepared_data.get_ml_features_at(evaluation_time)
        
        prediction = ml_model.predict(features)
        
        if prediction.confidence < strategy.min_ml_confidence:
            return FilterResult(False, f"Low ML confidence: {prediction.confidence:.2f} < {strategy.min_ml_confidence}")
        
        # äºˆæ¸¬ã‚·ã‚°ãƒŠãƒ«ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯
        if prediction.signal not in ['BUY', 'SELL', 'HOLD']:
            return FilterResult(False, f"Invalid ML signal: {prediction.signal}")
        
        return FilterResult(True, f"ML confidence acceptable: {prediction.confidence:.2f}", 
                          {
                              "ml_confidence": prediction.confidence,
                              "ml_signal": prediction.signal,
                              "ml_probability": prediction.probability
                          })

class VolatilityFilter(BaseFilter):
    def __init__(self):
        super().__init__("volatility", weight=2, timeout_seconds=25)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£è¨ˆç®—
        volatility = prepared_data.get_volatility_at(evaluation_time)
        
        # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ç¯„å›²ãƒã‚§ãƒƒã‚¯
        if volatility < strategy.min_volatility:
            return FilterResult(False, f"Low volatility: {volatility:.3f} < {strategy.min_volatility}")
        
        if volatility > strategy.max_volatility:
            return FilterResult(False, f"High volatility: {volatility:.3f} > {strategy.max_volatility}")
        
        # ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒˆãƒ¬ãƒ³ãƒ‰ãƒã‚§ãƒƒã‚¯
        volatility_trend = prepared_data.get_volatility_trend_at(evaluation_time)
        if volatility_trend == 'increasing' and volatility > strategy.max_volatility * 0.8:
            return FilterResult(False, "Rapidly increasing volatility detected")
        
        return FilterResult(True, f"Volatility within acceptable range: {volatility:.3f}",
                          {
                              "volatility": volatility,
                              "volatility_trend": volatility_trend
                          })
```

#### ğŸ“ é‡é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å®Ÿè£…ï¼ˆFilter 7-9ï¼‰

```python
# engines/filters/heavy_filters.py (æ–°è¦ä½œæˆ, 150è¡Œ)
class LeverageFilter(BaseFilter):
    def __init__(self):
        super().__init__("leverage", weight=3, timeout_seconds=35)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        sr_data = prepared_data.get_support_resistance_at(evaluation_time)
        ml_prediction = prepared_data.get_ml_prediction_at(evaluation_time)
        
        # ãƒ¬ãƒãƒ¬ãƒƒã‚¸è¨ˆç®—
        leverage_calculator = prepared_data.get_leverage_calculator()
        leverage_result = leverage_calculator.calculate_safe_leverage(
            sr_data, ml_prediction, strategy, evaluation_time
        )
        
        if not leverage_result.is_feasible:
            return FilterResult(False, f"Leverage calculation failed: {leverage_result.reason}")
        
        if leverage_result.recommended_leverage < strategy.min_leverage:
            return FilterResult(False, f"Leverage too low: {leverage_result.recommended_leverage:.1f}x < {strategy.min_leverage}x")
        
        if leverage_result.recommended_leverage > strategy.max_leverage:
            return FilterResult(False, f"Leverage too high: {leverage_result.recommended_leverage:.1f}x > {strategy.max_leverage}x")
        
        # ãƒªã‚¹ã‚¯è©•ä¾¡
        risk_assessment = leverage_calculator.assess_risk(leverage_result)
        if risk_assessment.risk_level > strategy.max_risk_level:
            return FilterResult(False, f"Risk level too high: {risk_assessment.risk_level}")
        
        return FilterResult(True, f"Leverage feasible: {leverage_result.recommended_leverage:.1f}x",
                          {
                              "recommended_leverage": leverage_result.recommended_leverage,
                              "risk_level": risk_assessment.risk_level,
                              "confidence_score": leverage_result.confidence_score
                          })

class RiskRewardFilter(BaseFilter):
    def __init__(self):
        super().__init__("risk_reward", weight=3, timeout_seconds=40)
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        sr_data = prepared_data.get_support_resistance_at(evaluation_time)
        leverage_data = prepared_data.get_leverage_data_at(evaluation_time)
        
        # ãƒªã‚¹ã‚¯ãƒªãƒ¯ãƒ¼ãƒ‰æ¯”è¨ˆç®—
        rr_calculator = prepared_data.get_risk_reward_calculator()
        rr_result = rr_calculator.calculate_ratio(sr_data, leverage_data, strategy)
        
        if rr_result.ratio < strategy.min_risk_reward:
            return FilterResult(False, f"Poor risk/reward ratio: {rr_result.ratio:.2f} < {strategy.min_risk_reward}")
        
        # æå¤±ãƒªã‚¹ã‚¯ã®è©³ç´°è©•ä¾¡
        max_loss_pct = rr_calculator.calculate_max_loss_percentage(rr_result)
        if max_loss_pct > strategy.max_acceptable_loss_pct:
            return FilterResult(False, f"Max loss too high: {max_loss_pct:.1f}% > {strategy.max_acceptable_loss_pct}%")
        
        # åˆ©ç›Šç›®æ¨™ã®å®Ÿç¾å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
        profit_probability = rr_calculator.calculate_profit_probability(rr_result)
        if profit_probability < strategy.min_profit_probability:
            return FilterResult(False, f"Low profit probability: {profit_probability:.2f}")
        
        return FilterResult(True, f"Risk/Reward ratio acceptable: {rr_result.ratio:.2f}",
                          {
                              "risk_reward_ratio": rr_result.ratio,
                              "max_loss_pct": max_loss_pct,
                              "profit_probability": profit_probability,
                              "expected_return": rr_result.expected_return
                          })

class StrategySpecificFilter(BaseFilter):
    def __init__(self, strategy):
        super().__init__(f"strategy_specific_{strategy.name}", weight=3, timeout_seconds=45)
        self.strategy = strategy
    
    def apply(self, evaluation_time, prepared_data, strategy):
        self.validate_input(evaluation_time, prepared_data, strategy)
        
        # æˆ¦ç•¥å›ºæœ‰ã®æ¡ä»¶ãƒã‚§ãƒƒã‚¯
        if strategy.name == "Conservative_ML":
            return self._apply_conservative_ml_conditions(evaluation_time, prepared_data, strategy)
        elif strategy.name == "Aggressive_ML":
            return self._apply_aggressive_ml_conditions(evaluation_time, prepared_data, strategy)
        elif strategy.name == "Balanced":
            return self._apply_balanced_conditions(evaluation_time, prepared_data, strategy)
        else:
            return FilterResult(True, "No specific conditions for this strategy")
    
    def _apply_conservative_ml_conditions(self, evaluation_time, prepared_data, strategy):
        """ä¿å®ˆçš„MLæˆ¦ç•¥ã®ç‰¹åˆ¥æ¡ä»¶"""
        # ã‚ˆã‚Šå³ã—ã„ä¿¡é ¼åº¦è¦ä»¶
        ml_prediction = prepared_data.get_ml_prediction_at(evaluation_time)
        if ml_prediction.confidence < 0.8:
            return FilterResult(False, f"Conservative ML requires high confidence: {ml_prediction.confidence:.2f} < 0.8")
        
        # BTCç›¸é–¢ãƒã‚§ãƒƒã‚¯
        btc_correlation = prepared_data.get_btc_correlation_at(evaluation_time)
        if abs(btc_correlation) > 0.7:
            return FilterResult(False, f"High BTC correlation: {abs(btc_correlation):.2f} > 0.7")
        
        return FilterResult(True, "Conservative ML conditions passed")
    
    def _apply_aggressive_ml_conditions(self, evaluation_time, prepared_data, strategy):
        """ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–MLæˆ¦ç•¥ã®ç‰¹åˆ¥æ¡ä»¶"""
        # é«˜ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£è¦ä»¶
        volatility = prepared_data.get_volatility_at(evaluation_time)
        if volatility < 0.03:
            return FilterResult(False, f"Aggressive ML requires higher volatility: {volatility:.3f} < 0.03")
        
        # MLä¿¡å·ã®å¼·åº¦ãƒã‚§ãƒƒã‚¯
        ml_prediction = prepared_data.get_ml_prediction_at(evaluation_time)
        if ml_prediction.signal_strength < 0.6:
            return FilterResult(False, f"Weak ML signal strength: {ml_prediction.signal_strength:.2f}")
        
        return FilterResult(True, "Aggressive ML conditions passed")
```

#### ğŸ”§ å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«
- `engines/filters/lightweight_filters.py` (æ–°è¦, 120è¡Œ)
- `engines/filters/medium_filters.py` (æ–°è¦, 100è¡Œ)
- `engines/filters/heavy_filters.py` (æ–°è¦, 150è¡Œ)
- `engines/filters/strategy_specific_filters.py` (æ–°è¦, 80è¡Œ)

### Phase 3: çµ±åˆãƒ»æœ€é©åŒ– (å·¥æ•°: 2-3æ—¥)

#### ğŸ“ ä½œæ¥­é …ç›®

**1. scalable_analysis_system.py ã¨ã®çµ±åˆ**
```python
# scalable_analysis_system.py ã¸ã®å¤‰æ›´ (100è¡Œå¤‰æ›´)
def _generate_real_analysis(self, symbol, timeframe, config, execution_id=None):
    """ãƒªã‚¢ãƒ«åˆ†æå®Ÿè¡Œï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµ±åˆç‰ˆï¼‰"""
    
    # Phase 1-5: äº‹å‰ãƒ‡ãƒ¼ã‚¿æº–å‚™ï¼ˆå¾“æ¥ã®é‡ã„å‡¦ç†ã‚’ä¸€æ‹¬å®Ÿè¡Œï¼‰
    prepared_data = self._prepare_comprehensive_analysis_data(symbol, timeframe, config, execution_id)
    
    if not prepared_data.is_valid():
        logger.error(f"æº–å‚™ãƒ‡ãƒ¼ã‚¿ãŒç„¡åŠ¹: {symbol} {timeframe} {config}")
        return []
    
    # Phase 6: ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§æ©Ÿä¼šæ¤œè¨¼
    logger.info(f"ğŸ” ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é–‹å§‹: {symbol} {timeframe} {config}")
    
    filtering_framework = FilteringFramework(config, prepared_data)
    evaluation_times = self._generate_evaluation_times(timeframe)
    
    logger.info(f"ğŸ“Š è©•ä¾¡æ™‚ç‚¹æ•°: {len(evaluation_times)}å€‹")
    
    # æ©Ÿä¼šæ¤œè¨¼å®Ÿè¡Œ
    start_time = time.time()
    valid_trades = filtering_framework.execute_filtering(evaluation_times)
    filtering_time = time.time() - start_time
    
    # ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµ±è¨ˆã‚’ãƒ­ã‚°å‡ºåŠ›
    filter_stats = filtering_framework.get_filtering_statistics()
    self._log_filtering_results(symbol, timeframe, config, 
                               len(evaluation_times), len(valid_trades), 
                               filtering_time, filter_stats)
    
    if not valid_trades:
        logger.warning(f"âš ï¸ {symbol} {timeframe} {config}: å…¨æ©Ÿä¼šãŒãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§é™¤å¤–")
        logger.info(f"ğŸ“Š ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çµ±è¨ˆ: {filter_stats}")
        return []
    
    logger.info(f"âœ… {symbol} {timeframe} {config}: {len(valid_trades)}å€‹ã®æœ‰åŠ¹æ©Ÿä¼šã‚’ç‰¹å®š")
    return valid_trades

def _prepare_comprehensive_analysis_data(self, symbol, timeframe, config, execution_id):
    """Phase 1-5ã®åŒ…æ‹¬çš„ãƒ‡ãƒ¼ã‚¿æº–å‚™"""
    
    logger.info(f"ğŸ“‹ ãƒ‡ãƒ¼ã‚¿æº–å‚™é–‹å§‹: {symbol} {timeframe}")
    
    # 1. ãƒ‡ãƒ¼ã‚¿æ¤œè¨¼
    ohlcv_data = self._fetch_and_validate_ohlcv_data(symbol, timeframe)
    
    # 2. æ”¯æŒç·šãƒ»æŠµæŠ—ç·šæ¤œå‡ºï¼ˆ1å›ã®ã¿å®Ÿè¡Œï¼‰
    sr_detector = self._get_support_resistance_detector()
    all_support_levels, all_resistance_levels = sr_detector.detect_comprehensive_levels(ohlcv_data)
    
    # 3. å¸‚å ´ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†æ
    market_context = self._analyze_market_context(ohlcv_data, symbol)
    
    # 4. MLäºˆæ¸¬ãƒ»å¼·åŒ–
    ml_model = self._train_or_load_ml_model(ohlcv_data, symbol, timeframe)
    
    # 5. ãƒ¬ãƒãƒ¬ãƒƒã‚¸æœ€é©åŒ–
    leverage_calculator = self._initialize_leverage_calculator(config)
    
    # æº–å‚™ãƒ‡ãƒ¼ã‚¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
    prepared_data = PreparedAnalysisData(
        ohlcv_data=ohlcv_data,
        support_levels=all_support_levels,
        resistance_levels=all_resistance_levels,
        market_context=market_context,
        ml_model=ml_model,
        leverage_calculator=leverage_calculator,
        symbol=symbol,
        timeframe=timeframe,
        config=config
    )
    
    logger.info(f"âœ… ãƒ‡ãƒ¼ã‚¿æº–å‚™å®Œäº†: {symbol} {timeframe}")
    return prepared_data

def _log_filtering_results(self, symbol, timeframe, config, total_evaluations, 
                          valid_trades, filtering_time, filter_stats):
    """ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµæœã®è©³ç´°ãƒ­ã‚°"""
    
    efficiency = (valid_trades / total_evaluations) * 100 if total_evaluations > 0 else 0
    
    logger.info(f"ğŸ“Š ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å®Œäº†: {symbol} {timeframe} {config}")
    logger.info(f"   â±ï¸ å®Ÿè¡Œæ™‚é–“: {filtering_time:.1f}ç§’")
    logger.info(f"   ğŸ“ˆ åŠ¹ç‡: {efficiency:.1f}% ({valid_trades}/{total_evaluations})")
    logger.info(f"   ğŸ” ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çµ±è¨ˆ:")
    
    for filter_name, excluded_count in filter_stats.items():
        if excluded_count > 0:
            exclusion_rate = (excluded_count / total_evaluations) * 100
            logger.info(f"      {filter_name}: {excluded_count}å€‹é™¤å¤– ({exclusion_rate:.1f}%)")
```

**2. é€²æ—è¿½è·¡ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µ**
```python
# web_dashboard/analysis_progress.py ã¸ã®è¿½åŠ  (50è¡Œ)
class FilteringProgressTracker:
    def __init__(self):
        self.filtering_stats = {}
    
    def update_filtering_progress(self, execution_id, current_filter, filter_stats, 
                                 current_evaluation, total_evaluations):
        """ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é€²æ—ã®æ›´æ–°"""
        progress_data = {
            "current_stage": "opportunity_validation",
            "current_filter": current_filter,
            "filtering_stats": filter_stats,
            "current_evaluation": current_evaluation,
            "total_evaluations": total_evaluations,
            "progress_percentage": (current_evaluation / total_evaluations) * 100,
            "remaining_opportunities": total_evaluations - sum(filter_stats.values())
        }
        self._update_progress_file(execution_id, progress_data)
    
    def update_filter_completion(self, execution_id, filter_name, excluded_count, 
                               exclusion_reason, total_excluded_so_far):
        """å€‹åˆ¥ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å®Œäº†ã®æ›´æ–°"""
        progress_data = {
            "last_completed_filter": filter_name,
            "last_excluded_count": excluded_count,
            "last_exclusion_reason": exclusion_reason,
            "total_excluded_so_far": total_excluded_so_far
        }
        self._update_progress_file(execution_id, progress_data)
    
    def complete_filtering_phase(self, execution_id, final_stats, valid_trades_count, 
                                total_time, efficiency):
        """ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†ã®æ›´æ–°"""
        progress_data = {
            "filtering_completed": True,
            "final_filtering_stats": final_stats,
            "valid_trades_count": valid_trades_count,
            "filtering_execution_time": total_time,
            "filtering_efficiency": efficiency,
            "next_stage": "result_finalization"
        }
        self._update_progress_file(execution_id, progress_data)
```

**3. Web UI ã§ã®å¯è¦–åŒ–å¼·åŒ–**
```html
<!-- web_dashboard/templates/analysis_progress.html ã¸ã®è¿½åŠ  (80è¡Œ) -->
<div id="filtering-progress" class="progress-section" style="display: none;">
    <h3>ğŸ” æ©Ÿä¼šæ¤œè¨¼ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°</h3>
    
    <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒã‚§ãƒ¼ãƒ³å¯è¦–åŒ– -->
    <div class="filter-chain">
        <div class="filter-step" data-filter="1" data-weight="light">
            <div class="filter-info">
                <span class="filter-name">ãƒ‡ãƒ¼ã‚¿å“è³ª</span>
                <span class="filter-weight">è»½é‡</span>
            </div>
            <div class="filter-result">
                <span class="status" id="filter-1-status">å¾…æ©Ÿä¸­</span>
                <span class="excluded-count" id="filter-1-excluded">-</span>
            </div>
        </div>
        
        <div class="filter-step" data-filter="2" data-weight="light">
            <div class="filter-info">
                <span class="filter-name">å¸‚å ´æ¡ä»¶</span>
                <span class="filter-weight">è»½é‡</span>
            </div>
            <div class="filter-result">
                <span class="status" id="filter-2-status">å¾…æ©Ÿä¸­</span>
                <span class="excluded-count" id="filter-2-excluded">-</span>
            </div>
        </div>
        
        <!-- Filter 3-9 åŒæ§˜ã«è¿½åŠ  -->
        <div class="filter-step" data-filter="9" data-weight="heavy">
            <div class="filter-info">
                <span class="filter-name">æˆ¦ç•¥å›ºæœ‰</span>
                <span class="filter-weight">é‡é‡</span>
            </div>
            <div class="filter-result">
                <span class="status" id="filter-9-status">å¾…æ©Ÿä¸­</span>
                <span class="excluded-count" id="filter-9-excluded">-</span>
            </div>
        </div>
    </div>
    
    <!-- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°çµ±è¨ˆ -->
    <div class="filtering-summary">
        <div class="summary-item">
            <label>ç·è©•ä¾¡æ™‚ç‚¹:</label>
            <span id="total-evaluations">-</span>
        </div>
        <div class="summary-item">
            <label>ç¾åœ¨è©•ä¾¡:</label>
            <span id="current-evaluation">-</span>
        </div>
        <div class="summary-item">
            <label>æœ‰åŠ¹æ©Ÿä¼š:</label>
            <span id="valid-opportunities">-</span>
        </div>
        <div class="summary-item">
            <label>åŠ¹ç‡:</label>
            <span id="filtering-efficiency">-</span>%
        </div>
        <div class="summary-item">
            <label>å®Ÿè¡Œæ™‚é–“:</label>
            <span id="filtering-execution-time">-</span>ç§’
        </div>
    </div>
    
    <!-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
    <div class="filtering-progress-bar">
        <div class="progress-bar-fill" id="filtering-progress-fill" style="width: 0%;"></div>
        <div class="progress-text" id="filtering-progress-text">0%</div>
    </div>
</div>

<style>
.filter-chain {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin: 15px 0;
}

.filter-step {
    border: 2px solid #ddd;
    border-radius: 8px;
    padding: 10px;
    min-width: 120px;
    text-align: center;
}

.filter-step[data-weight="light"] {
    border-color: #28a745;
    background-color: #f8fff9;
}

.filter-step[data-weight="medium"] {
    border-color: #ffc107;
    background-color: #fffdf0;
}

.filter-step[data-weight="heavy"] {
    border-color: #dc3545;
    background-color: #fff5f5;
}

.filter-step.processing {
    border-color: #007bff;
    background-color: #f0f8ff;
}

.filter-step.completed {
    border-color: #6c757d;
    background-color: #f8f9fa;
}

.filter-name {
    font-weight: bold;
    display: block;
}

.filter-weight {
    font-size: 0.8em;
    color: #666;
    display: block;
}

.status {
    display: block;
    margin-top: 5px;
}

.excluded-count {
    font-weight: bold;
    color: #dc3545;
    display: block;
}

.filtering-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 10px;
    margin: 15px 0;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 8px;
}

.summary-item {
    text-align: center;
}

.summary-item label {
    display: block;
    font-weight: bold;
    margin-bottom: 5px;
}

.filtering-progress-bar {
    position: relative;
    width: 100%;
    height: 30px;
    background-color: #e9ecef;
    border-radius: 15px;
    overflow: hidden;
}

.progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #28a745, #20c997);
    transition: width 0.3s ease;
}

.progress-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-weight: bold;
    color: #333;
}
</style>
```

```javascript
// web_dashboard/static/js/filtering_progress.js (æ–°è¦ä½œæˆ, 120è¡Œ)
class FilteringProgressManager {
    constructor() {
        this.filterElements = {};
        this.summaryElements = {};
        this.initializeElements();
    }
    
    initializeElements() {
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¦ç´ ã®å–å¾—
        for (let i = 1; i <= 9; i++) {
            this.filterElements[i] = {
                step: document.querySelector(`[data-filter="${i}"]`),
                status: document.getElementById(`filter-${i}-status`),
                excluded: document.getElementById(`filter-${i}-excluded`)
            };
        }
        
        // ã‚µãƒãƒªãƒ¼è¦ç´ ã®å–å¾—
        this.summaryElements = {
            totalEvaluations: document.getElementById('total-evaluations'),
            currentEvaluation: document.getElementById('current-evaluation'),
            validOpportunities: document.getElementById('valid-opportunities'),
            efficiency: document.getElementById('filtering-efficiency'),
            executionTime: document.getElementById('filtering-execution-time')
        };
        
        this.progressBar = document.getElementById('filtering-progress-fill');
        this.progressText = document.getElementById('filtering-progress-text');
    }
    
    updateProgress(progressData) {
        if (progressData.current_stage === 'opportunity_validation') {
            this.showFilteringSection();
            this.updateFilteringProgress(progressData);
        }
    }
    
    showFilteringSection() {
        const section = document.getElementById('filtering-progress');
        if (section) {
            section.style.display = 'block';
        }
    }
    
    updateFilteringProgress(data) {
        // åŸºæœ¬çµ±è¨ˆã®æ›´æ–°
        if (data.total_evaluations) {
            this.summaryElements.totalEvaluations.textContent = data.total_evaluations.toLocaleString();
        }
        
        if (data.current_evaluation) {
            this.summaryElements.currentEvaluation.textContent = data.current_evaluation.toLocaleString();
        }
        
        if (data.remaining_opportunities !== undefined) {
            this.summaryElements.validOpportunities.textContent = data.remaining_opportunities.toLocaleString();
        }
        
        if (data.progress_percentage !== undefined) {
            const percentage = Math.round(data.progress_percentage);
            this.progressBar.style.width = `${percentage}%`;
            this.progressText.textContent = `${percentage}%`;
        }
        
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼çµ±è¨ˆã®æ›´æ–°
        if (data.filtering_stats) {
            this.updateFilterStatistics(data.filtering_stats);
        }
        
        // ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (data.current_filter) {
            this.highlightCurrentFilter(data.current_filter);
        }
        
        // å®Ÿè¡Œæ™‚é–“ã®æ›´æ–°
        if (data.filtering_execution_time) {
            this.summaryElements.executionTime.textContent = `${data.filtering_execution_time.toFixed(1)}`;
        }
        
        // åŠ¹ç‡ã®è¨ˆç®—ã¨è¡¨ç¤º
        if (data.total_evaluations && data.remaining_opportunities !== undefined) {
            const efficiency = (data.remaining_opportunities / data.total_evaluations) * 100;
            this.summaryElements.efficiency.textContent = efficiency.toFixed(1);
        }
    }
    
    updateFilterStatistics(filterStats) {
        for (let i = 1; i <= 9; i++) {
            const filterKey = `filter_${i}`;
            const excludedCount = filterStats[filterKey] || 0;
            
            if (this.filterElements[i]) {
                this.filterElements[i].excluded.textContent = excludedCount > 0 ? excludedCount.toLocaleString() : '-';
                
                if (excludedCount > 0) {
                    this.filterElements[i].step.classList.add('completed');
                    this.filterElements[i].status.textContent = 'å®Œäº†';
                } else {
                    this.filterElements[i].status.textContent = 'å¾…æ©Ÿä¸­';
                }
            }
        }
    }
    
    highlightCurrentFilter(currentFilter) {
        // å…¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®processingã‚¯ãƒ©ã‚¹ã‚’å‰Šé™¤
        for (let i = 1; i <= 9; i++) {
            if (this.filterElements[i]) {
                this.filterElements[i].step.classList.remove('processing');
            }
        }
        
        // ç¾åœ¨ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        const filterNumber = this.extractFilterNumber(currentFilter);
        if (filterNumber && this.filterElements[filterNumber]) {
            this.filterElements[filterNumber].step.classList.add('processing');
            this.filterElements[filterNumber].status.textContent = 'å®Ÿè¡Œä¸­';
        }
    }
    
    extractFilterNumber(filterName) {
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åã‹ã‚‰ç•ªå·ã‚’æŠ½å‡º
        const filterMap = {
            'data_quality': 1,
            'market_condition': 2,
            'support_resistance': 3,
            'distance_analysis': 4,
            'ml_confidence': 5,
            'volatility': 6,
            'leverage': 7,
            'risk_reward': 8,
            'strategy_specific': 9
        };
        
        for (const [name, number] of Object.entries(filterMap)) {
            if (filterName.includes(name)) {
                return number;
            }
        }
        return null;
    }
    
    completeFiltering(finalData) {
        // å…¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’å®Œäº†çŠ¶æ…‹ã«
        for (let i = 1; i <= 9; i++) {
            if (this.filterElements[i]) {
                this.filterElements[i].step.classList.remove('processing');
                this.filterElements[i].step.classList.add('completed');
                this.filterElements[i].status.textContent = 'å®Œäº†';
            }
        }
        
        // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’100%ã«
        this.progressBar.style.width = '100%';
        this.progressText.textContent = '100%';
        
        // æœ€çµ‚çµ±è¨ˆã®è¡¨ç¤º
        if (finalData.valid_trades_count) {
            this.summaryElements.validOpportunities.textContent = finalData.valid_trades_count.toLocaleString();
        }
        
        if (finalData.filtering_efficiency) {
            this.summaryElements.efficiency.textContent = `${finalData.filtering_efficiency.toFixed(1)}`;
        }
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
window.filteringProgressManager = new FilteringProgressManager();

// æ—¢å­˜ã®progressæ›´æ–°ã‚·ã‚¹ãƒ†ãƒ ã«çµ±åˆ
if (window.updateProgress) {
    const originalUpdateProgress = window.updateProgress;
    window.updateProgress = function(progressData) {
        originalUpdateProgress(progressData);
        window.filteringProgressManager.updateProgress(progressData);
    };
}
```

#### ğŸ”§ å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«
- `scalable_analysis_system.py` (100è¡Œå¤‰æ›´)
- `web_dashboard/analysis_progress.py` (50è¡Œè¿½åŠ )
- `web_dashboard/templates/analysis_progress.html` (80è¡Œè¿½åŠ )
- `web_dashboard/static/js/filtering_progress.js` (æ–°è¦, 120è¡Œ)

### Phase 4: ãƒ†ã‚¹ãƒˆãƒ»æ¤œè¨¼ (å·¥æ•°: 3-4æ—¥)

#### ğŸ§ª å¿…è¦ãªãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹è¨­è¨ˆ

**å˜ä½“ãƒ†ã‚¹ãƒˆ**
- å„ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®å€‹åˆ¥æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
- å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆ
- ç•°å¸¸ç³»ãƒ†ã‚¹ãƒˆ

**çµ±åˆãƒ†ã‚¹ãƒˆ**
- ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒã‚§ãƒ¼ãƒ³å…¨ä½“ãƒ†ã‚¹ãƒˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼æ•´åˆæ€§ãƒ†ã‚¹ãƒˆ
- ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ

**ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**
- å‡¦ç†æ™‚é–“æ¸¬å®šãƒ†ã‚¹ãƒˆ
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒ†ã‚¹ãƒˆ
- ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ

**å›å¸°ãƒ†ã‚¹ãƒˆ**
- æ—¢å­˜æ©Ÿèƒ½äº’æ›æ€§ãƒ†ã‚¹ãƒˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒäº’æ›æ€§ãƒ†ã‚¹ãƒˆ
- åˆ†æçµæœä¸€è²«æ€§ãƒ†ã‚¹ãƒˆ

## ğŸ“Š å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã¨å·¥æ•°è¦‹ç©ã‚Š

### ğŸ“… å®Ÿè£…ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ (ç·å·¥æ•°: 13-17æ—¥)

| Phase | æœŸé–“ | å·¥æ•° | ä¸»è¦æˆæœç‰© | å®Œäº†åŸºæº– |
|-------|------|------|------------|----------|
| **Phase 1** | Week 1 | 3-4æ—¥ | ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°åŸºç›¤ | åŸºåº•ã‚¯ãƒ©ã‚¹ãƒ»ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å®Œæˆ |
| **Phase 2** | Week 2 | 5-6æ—¥ | å…¨ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å®Ÿè£… | 9æ®µéšãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å‹•ä½œç¢ºèª |
| **Phase 3** | Week 3 | 2-3æ—¥ | ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ | æ—¢å­˜ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨ã®çµ±åˆ |
| **Phase 4** | Week 4 | 3-4æ—¥ | ãƒ†ã‚¹ãƒˆãƒ»æ¤œè¨¼ | å…¨ãƒ†ã‚¹ãƒˆé€šéãƒ»æ€§èƒ½ç›®æ¨™é”æˆ |

### ğŸ¯ å®Ÿè£…å„ªå…ˆåº¦

#### **é«˜å„ªå…ˆåº¦ (P1) - Week 1-2**
- Filter 1-3 (è»½é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼)
- åŸºæœ¬çš„ãªãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
- auto_symbol_training.py ã¨ã®åŸºæœ¬çµ±åˆ

#### **ä¸­å„ªå…ˆåº¦ (P2) - Week 2-3**  
- Filter 4-6 (ä¸­é‡é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼)
- é€²æ—è¿½è·¡ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µ
- Web UI ã§ã®å¯è¦–åŒ–

#### **ä½å„ªå…ˆåº¦ (P3) - Week 3-4**
- Filter 7-9 (é‡é‡ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼)
- é«˜åº¦ãªæœ€é©åŒ–æ©Ÿèƒ½
- åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ

## ğŸ“ˆ äºˆæƒ³ã•ã‚Œã‚‹åŠ¹æœã¨ROI

### ğŸ“Š å®šé‡çš„æ”¹å–„åŠ¹æœ

#### **å‡¦ç†æ™‚é–“çŸ­ç¸®**
- **ç¾è¡Œ**: éŠ˜æŸ„ã‚ãŸã‚Š15-30åˆ† (18æˆ¦ç•¥ Ã— 5000è©•ä¾¡ = é‡ã„å‡¦ç†)
- **æœ€é©åŒ–å¾Œ**: éŠ˜æŸ„ã‚ãŸã‚Š3-7åˆ† (ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã«ã‚ˆã‚Š80-90%é™¤å¤–)
- **å‰Šæ¸›ç‡**: **70-85%çŸ­ç¸®**

#### **ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡å‰Šæ¸›**
- **CPUä½¿ç”¨ç‡**: 60%å‰Šæ¸› (ä¸è¦ãªè¨ˆç®—å‡¦ç†ã®é™¤å¤–)
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: 70%å‰Šæ¸› (å¤§é‡ã®ä¸€æ™‚ãƒ‡ãƒ¼ã‚¿å‰Šé™¤)
- **APIå‘¼ã³å‡ºã—**: 85%å‰Šæ¸› (äº‹å‰è¨ˆç®—ã«ã‚ˆã‚‹é‡è¤‡é™¤å»)

#### **ã‚·ã‚¹ãƒ†ãƒ å®‰å®šæ€§å‘ä¸Š**
- **åŒæ™‚å‡¦ç†å¯èƒ½éŠ˜æŸ„æ•°**: 3-5å€å¢—åŠ 
- **Rate Limitå•é¡Œ**: æ ¹æœ¬çš„è§£æ±º
- **ã‚¨ãƒ©ãƒ¼ç‡**: 50%å‰Šæ¸› (æ—©æœŸå•é¡Œæ¤œå‡º)

### ğŸ¯ æˆ¦ç•¥çš„ä¾¡å€¤

#### **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£å‘ä¸Š**
- æ–°è¦éŠ˜æŸ„è¿½åŠ æ™‚ã®å‡¦ç†æ™‚é–“äºˆæ¸¬å¯èƒ½æ€§
- å¤§é‡éŠ˜æŸ„ã®ä¸€æ‹¬å‡¦ç†å¯¾å¿œ
- å°†æ¥çš„ãªãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–æ©Ÿèƒ½ã¸ã®åŸºç›¤æä¾›

#### **é‹ç”¨åŠ¹ç‡å‘ä¸Š**  
- ãƒ‡ãƒãƒƒã‚°æ™‚é–“ã®å¤§å¹…çŸ­ç¸®ï¼ˆæ®µéšåˆ¥ãƒ­ã‚°ï¼‰
- å•é¡Œç‰¹å®šã®é«˜é€ŸåŒ–ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼åˆ¥çµ±è¨ˆï¼‰
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚µãƒãƒ¼ãƒˆå·¥æ•°å‰Šæ¸›ï¼ˆæ˜ç¢ºãªé™¤å¤–ç†ç”±ï¼‰

### âš ï¸ ä¸»è¦ãƒªã‚¹ã‚¯è¦å› ã¨è»½æ¸›ç­–

#### **æŠ€è¡“çš„ãƒªã‚¹ã‚¯**
1. **ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ç²¾åº¦**: éåº¦ãªé™¤å¤–ã«ã‚ˆã‚Šæœ‰åŠ¹æ©Ÿä¼šã‚’é€ƒã™ãƒªã‚¹ã‚¯
   - **è»½æ¸›ç­–**: A/Bãƒ†ã‚¹ãƒˆã§ã®é–¾å€¤èª¿æ•´ã€æ®µéšçš„ãƒ‡ãƒ—ãƒ­ã‚¤

2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: æœŸå¾…ã—ãŸå‡¦ç†æ™‚é–“çŸ­ç¸®ãŒå¾—ã‚‰ã‚Œãªã„ãƒªã‚¹ã‚¯  
   - **è»½æ¸›ç­–**: Phaseåˆ¥ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã€ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ãƒ„ãƒ¼ãƒ«æ´»ç”¨

3. **ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§**: æ—¢å­˜çµæœã¨ã®ä¸æ•´åˆãƒªã‚¹ã‚¯
   - **è»½æ¸›ç­–**: åŒ…æ‹¬çš„å›å¸°ãƒ†ã‚¹ãƒˆã€ä¸¦è¡Œç¨¼åƒæœŸé–“ã®è¨­å®š

#### **é‹ç”¨ãƒªã‚¹ã‚¯**
1. **ãƒ¦ãƒ¼ã‚¶ãƒ¼å½±éŸ¿**: åˆ†æçµæœã®å¤‰åŒ–ã«ã‚ˆã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼æ··ä¹±
   - **è»½æ¸›ç­–**: è©³ç´°ãªå¤‰æ›´ãƒ­ã‚°æä¾›ã€æ®µéšçš„ãƒ­ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆ

2. **ã‚·ã‚¹ãƒ†ãƒ åœæ­¢**: å®Ÿè£…æ™‚ã®ä¸€æ™‚çš„ãªæ©Ÿèƒ½åœæ­¢
   - **è»½æ¸›ç­–**: ãƒ–ãƒ«ãƒ¼ã‚°ãƒªãƒ¼ãƒ³ãƒ‡ãƒ—ãƒ­ã‚¤ã€å³åº§ã®ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½

---

## ğŸ¯ çµè«–

ã“ã®æ—©æœŸãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ–¹å¼ã«ã‚ˆã‚Šã€ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆå°‚ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®**æ ¹æœ¬çš„ãªæ€§èƒ½æ”¹å–„**ã¨**å°†æ¥æ‹¡å¼µæ€§ã®ç¢ºä¿**ã€ãã—ã¦**é‹ç”¨å®‰å®šæ€§ã®å‘ä¸Š**ã‚’åŒæ™‚ã«å®Ÿç¾ã§ãã¾ã™ã€‚

ç‰¹ã«**9æ®µéšãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ **ã«ã‚ˆã‚Šã€ZORAã®ã‚ˆã†ãªæ–°è¦ä¸Šå ´éŠ˜æŸ„ã§90æ—¥åˆ†ã®OHLCVãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã™ã‚‹å•é¡Œã‚„ã€é‡ã„ãƒãƒ«ãƒãƒ—ãƒ­ã‚»ã‚¹å‡¦ç†ãŒç„¡é§„ã«å®Ÿè¡Œã•ã‚Œã‚‹å•é¡Œã‚’æ ¹æœ¬çš„ã«è§£æ±ºã—ã€å‡¦ç†æ™‚é–“ã‚’**70-85%çŸ­ç¸®**ã™ã‚‹å¤§å¹…ãªæœ€é©åŒ–ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

**2025å¹´6æœˆ26æ—¥ ç­–å®š**  
**è¨­è¨ˆè€…**: Claude Code  
**å„ªå…ˆåº¦**: é«˜ï¼ˆãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã¨ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆã®åŠ¹ç‡çš„åˆ†é›¢ï¼‰